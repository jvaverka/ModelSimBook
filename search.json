[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Modeling and Simulation with Julia",
    "section": "",
    "text": "Why?\nThe Julia Programming Language is revolutionizing technical and scientific computing across many industries. Language features such as differentiability and multiple dispatch have made Julia the perfect tool for building SciML - an open source ecosystem for scientific machine learning libraries.\nAmoung many other modules, the SciML ecosystem includes an acausal modeling framework and the most comprehensive collection of differential equation solvers that exists today. These modules form the fundation of SciML and their flexibility makes them viable tools for working in any industry. I believe these tools are so powerful that they open the door to advanced modeling and simulation capabilities in more domains than ever before. Therefore, this project details my learning how to perform modeling and simulation to solve real problems with Julia and SciML.\nThe best hope I have to achieve my goal is to stand on the shoulders of giants. What follows is a collection of notes, teachings and exercises from the exceptional books Principle of Object-Oriented Modeling and Simulation with Modelica 3.31 by Dr. Peter Fritzson and Modelica by Example2 by Dr. Michael M. Tiller. All content is translated to Julia and uses various modules from SciMl. Both of these books delve into modeling and simulation using Modelica which is a fantastic starting point since this is the foundation of many great tools which have established industrial modeling and simulation today. Thank you everyone that contributed to these works."
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Modeling and Simulation with Julia",
    "section": "",
    "text": "Fritzson covers the Modelica language in impressive depth from the basic concepts such as cyber-physical, equation-base, object-oriented, system, model, and simulation, while also incorporating over a hundred exercises and their solutions for a tutorial, easy-to-read experience. Find a copy at https://ieeexplore.ieee.org/book/7022515.↩︎\nTiller takes a different and welcome approach by covering the Modelica language with practical examples and by optimizing the book for online consumption. The book is available for free at https://mbe.modelica.university/ and provides a rich and interactive learning environment.↩︎"
  },
  {
    "objectID": "intro.html#hello-modelingtoolkit",
    "href": "intro.html#hello-modelingtoolkit",
    "title": "1  Introduction",
    "section": "1.1 Hello, ModelingToolkit!",
    "text": "1.1 Hello, ModelingToolkit!\nFirst, load all modules needed for the hello, world example for ModelingToolkit.jl.\n\n1using ModelingToolkit\n2using ModelingToolkitStandardLibrary\n3using DifferentialEquations\n4using Plots\n\n\n1\n\nAcausal modeling framework for building models\n\n2\n\nCollection of reusable component models commonly used in modeling various systems\n\n3\n\nState-of-the-art collection of differential equations solvers\n\n4\n\nCreating visualizations from simulation outputs\n\n\n\n\nNext, the independent and dependent variables are defined.\nHere, t is the independent variable representing time and x is a variable which depends on time, t.\n\n@variables t x(t)\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{c}\nt \\\\\nx\\left( t \\right) \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\n\n\nAn operator must also be defined which performs differentiation with respect to time, t.\n\nD = Differential(t)\n\n(::Differential) (generic function with 3 methods)\n\n\nModel parameters are defined in a similar fashion. These are inputs not outputs.\n\n@parameters τ\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{c}\n\\tau \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\n\n\nConstants can also be defined to represent known quantities, e.g., gravity, speed of light, etc.\n\n@constants h = 1\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{c}\nh \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\n\n\nCreate a system of ordinary differential equations, of type ODESystem, which consists of a single equation.\n\n@named fol = ODESystem([D(x) ~ (h - x) / τ])\n\n\\[ \\begin{align}\n\\frac{\\mathrm{d} x\\left( t \\right)}{\\mathrm{d}t} =& \\frac{h - x\\left( t \\right)}{\\tau}\n\\end{align}\n\\]\n\n\nNow that a system or _model_exists, we must describe a simulation that we want to perform on this model. We call this a problem, and assign it to type ODEProblem.\nThere are several inputs we can use to create the problem we wish to study - to start, only consider the ordered arguments shown below:\n\nmodel which has type ODESystem\ninitial conditions which is represented by a Pair1\ntime span which is represented by a Tuple2\nparameter values which again is represented by a Pair\n\n\nprob = ODEProblem(fol, [x =&gt; 0.0], (0.0, 10.0), [τ =&gt; 3.0])\n\n\nODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 10.0)\nu0: 1-element Vector{Float64}:\n 0.0\n\n\n\nOnce a problem has been defined, we use the common solve interface. In this simple example, only 1 argument is provided - the ODEProblem.\n\nsol = solve(prob)\n\nretcode: Success\nInterpolation: specialized 4th order \"free\" interpolation, specialized 2nd order \"free\" stiffness-aware interpolation\nt: 14-element Vector{Float64}:\n  0.0\n  9.999999999999999e-5\n  0.0010999999999999998\n  0.011099999999999997\n  0.11109999999999996\n  0.44196924781807967\n  1.0112520758966859\n  1.7621013896357889\n  2.7411196006326954\n  3.954782507222947\n  5.435343082434807\n  7.201735027334962\n  9.291406745592692\n 10.0\nu: 14-element Vector{Vector{Float64}}:\n [0.0]\n [3.333277778395056e-5]\n [0.00036659945265974064]\n [0.0036931634343634343]\n [0.03635598665335361]\n [0.13698489268755673]\n [0.28615114066001385]\n [0.44421130189743585]\n [0.5989648996141729]\n [0.7323994349297618]\n [0.836636389514038]\n [0.9093330812230747]\n [0.9548191028045533]\n [0.9643240555350271]\n\n\n\nsol isa ODESolution\n\ntrue\n\n\nFinally, we want to create a graph using the data from our solution. This is very easy since there exists a plotting recipe specifically for ODESolution objects (which you can see from above is exactly the type produces by the solve function).\n\nplot(sol)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThat was easy! There is only one output plotted because there was only one dependent variable in our model. When working with larger models, specify which variables should be plotted by providing a list to the idxs keyword argument (along with any other attributes you want to modify).\n\nplot(\n    sol;\n    idxs=[x],\n    size=(300,200),\n    title=\"Hello!\",\n    ylabel=\"unit\",\n    legend=:outerbottomright,\n    color=:purple,\n    linewidth=3,\n    linestyle=:dash\n)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "1  Introduction",
    "section": "",
    "text": "In Julia, a Pair is a collection of two elements. A Pair has fields first and second for accessing each element. To construct a Pair, the sytax is [first =&gt; second] (notice the surrounding square brackets).↩︎\nIn Julia, a Tuple is a collection of any number of elements. Accessing elements of a Tuple is only possible using their index as a Tuple does not have field names. To construct a Tuple, the syntax is (1, 'b', pi)(notice the surrounding parentheses).↩︎"
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "2  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "3  References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  }
]